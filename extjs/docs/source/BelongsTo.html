<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).cl***REMOVED***Name = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre cl***REMOVED***="prettyprint lang-js"><span id='Ext-data-***REMOVED***ociation-BelongsTo'>/**
</span> * @author Ed Spencer
 * @cl***REMOVED*** Ext.data.***REMOVED***ociation.BelongsTo
 *
 * Represents a many to one ***REMOVED***ociation with another model. The owner model is expected to have
 * a foreign key which references the primary key of the ***REMOVED***ociated model:
 *
 *     Ext.define('Category', {
 *         extend: 'Ext.data.Model',
 *         fields: [
 *             { name: 'id',   type: 'int' },
 *             { name: 'name', type: 'string' }
 *         ]
 *     });
 *
 *     Ext.define('Product', {
 *         extend: 'Ext.data.Model',
 *         fields: [
 *             { name: 'id',          type: 'int' },
 *             { name: 'category_id', type: 'int' },
 *             { name: 'name',        type: 'string' }
 *         ],
 *         // we can use the belongsTo shortcut on the model to create a belongsTo ***REMOVED***ociation
 *         ***REMOVED***ociations: [
 *             { type: 'belongsTo', model: 'Category' }
 *         ]
 *     });
 *
 * In the example above we have created models for Products and Categories, and linked them together
 * by saying that each Product belongs to a Category. This automatically links each Product to a Category
 * based on the Product's category_id, and provides new functions on the Product model:
 *
 * ## Generated getter function
 *
 * The first function that is added to the owner model is a getter function:
 *
 *     var product = new Product({
 *         id: 100,
 *         category_id: 20,
 *         name: 'Sneakers'
 *     });
 *
 *     product.getCategory(function(category, operation) {
 *         // do something with the category object
 *         alert(category.get('id')); // alerts 20
 *     }, this);
 *
 * The getCategory function was created on the Product model when we defined the ***REMOVED***ociation. This uses the
 * Category's configured {@link Ext.data.proxy.Proxy proxy} to load the Category asynchronously, calling the provided
 * callback when it has loaded.
 *
 * The new getCategory function will also accept an object containing success, failure and callback properties
 * - callback will always be called, success will only be called if the ***REMOVED***ociated model was loaded successfully
 * and failure will only be called if the ***REMOVED***ociatied model could not be loaded:
 *
 *     product.getCategory({
 *         reload: true, // force a reload if the owner model is already cached
 *         callback: function(category, operation) {}, // a function that will always be called
 *         success : function(category, operation) {}, // a function that will only be called if the load succeeded
 *         failure : function(category, operation) {}, // a function that will only be called if the load did not succeed
 *         scope   : this // optionally p***REMOVED*** in a scope object to execute the callbacks in
 *     });
 *
 * In each case above the callbacks are called with two arguments - the ***REMOVED***ociated model instance and the
 * {@link Ext.data.Operation operation} object that was executed to load that instance. The Operation object is
 * useful when the instance could not be loaded.
 * 
 * Once the getter has been called on the model, it will be cached if the getter is called a second time. To
 * force the model to reload, specify reload: true in the options object.
 *
 * ## Generated setter function
 *
 * The second generated function sets the ***REMOVED***ociated model instance - if only a single argument is p***REMOVED***ed to
 * the setter then the following two calls are identical:
 *
 *     // this call...
 *     product.setCategory(10);
 *
 *     // is equivalent to this call:
 *     product.set('category_id', 10);
 *     
 * An instance of the owner model can also be p***REMOVED***ed as a parameter.
 *
 * If we p***REMOVED*** in a second argument, the model will be automatically saved and the second argument p***REMOVED***ed to
 * the owner model's {@link Ext.data.Model#save save} method:
 *
 *     product.setCategory(10, function(product, operation) {
 *         // the product has been saved
 *         alert(product.get('category_id')); //now alerts 10
 *     });
 *
 *     //alternative syntax:
 *     product.setCategory(10, {
 *         callback: function(product, operation), // a function that will always be called
 *         success : function(product, operation), // a function that will only be called if the load succeeded
 *         failure : function(product, operation), // a function that will only be called if the load did not succeed
 *         scope   : this //optionally p***REMOVED*** in a scope object to execute the callbacks in
 *     })
 *
 * ## Customisation
 *
 * Associations reflect on the models they are linking to automatically set up properties such as the
 * {@link #primaryKey} and {@link #foreignKey}. These can alternatively be specified:
 *
 *     Ext.define('Product', {
 *         fields: [...],
 *
 *         ***REMOVED***ociations: [
 *             { type: 'belongsTo', model: 'Category', primaryKey: 'unique_id', foreignKey: 'cat_id' }
 *         ]
 *     });
 *
 * Here we replaced the default primary key (defaults to 'id') and foreign key (calculated as 'category_id')
 * with our own settings. Usually this will not be needed.
 */
Ext.define('Ext.data.***REMOVED***ociation.BelongsTo', {
    extend: 'Ext.data.***REMOVED***ociation.Association',
    alternateCl***REMOVED***Name: 'Ext.data.BelongsToAssociation',
    alias: '***REMOVED***ociation.belongsto',

<span id='Ext-data-***REMOVED***ociation-BelongsTo-cfg-foreignKey'>    /**
</span>     * @cfg {String} foreignKey The name of the foreign key on the owner model that links it to the ***REMOVED***ociated
     * model. Defaults to the lowercased name of the ***REMOVED***ociated model plus &quot;_id&quot;, e.g. an ***REMOVED***ociation with a
     * model called Product would set up a product_id foreign key.
     *
     *     Ext.define('Order', {
     *         extend: 'Ext.data.Model',
     *         fields: ['id', 'date'],
     *         hasMany: 'Product'
     *     });
     *
     *     Ext.define('Product', {
     *         extend: 'Ext.data.Model',
     *         fields: ['id', 'name', 'order_id'], // refers to the id of the order that this product belongs to
     *         belongsTo: 'Order'
     *     });
     *     var product = new Product({
     *         id: 1,
     *         name: 'Product 1',
     *         order_id: 22
     *     }, 1);
     *     product.getOrder(); // Will make a call to the server asking for order_id 22
     *
     */

<span id='Ext-data-***REMOVED***ociation-BelongsTo-cfg-getterName'>    /**
</span>     * @cfg {String} getterName The name of the getter function that will be added to the local model's prototype.
     * Defaults to 'get' + the name of the foreign model, e.g. getCategory
     */

<span id='Ext-data-***REMOVED***ociation-BelongsTo-cfg-setterName'>    /**
</span>     * @cfg {String} setterName The name of the setter function that will be added to the local model's prototype.
     * Defaults to 'set' + the name of the foreign model, e.g. setCategory
     */

<span id='Ext-data-***REMOVED***ociation-BelongsTo-cfg-type'>    /**
</span>     * @cfg {String} type The type configuration can be used when creating ***REMOVED***ociations using a configuration object.
     * Use 'belongsTo' to create a BelongsTo ***REMOVED***ociation.
     *
     *     ***REMOVED***ociations: [{
     *         type: 'belongsTo',
     *         model: 'User'
     *     }]
     */
    constructor: function(config) {
        this.callParent(arguments);

        var me             = this,
            ownerProto     = me.ownerModel.prototype,
            ***REMOVED***ociatedName = me.***REMOVED***ociatedName,
            getterName     = me.getterName || 'get' + ***REMOVED***ociatedName,
            setterName     = me.setterName || 'set' + ***REMOVED***ociatedName;

        Ext.applyIf(me, {
            name        : ***REMOVED***ociatedName,
            foreignKey  : ***REMOVED***ociatedName.toLowerCase() + &quot;_id&quot;,
            instanceName: ***REMOVED***ociatedName + 'BelongsToInstance',
            ***REMOVED***ociationKey: ***REMOVED***ociatedName.toLowerCase()
        });

        ownerProto[getterName] = me.createGetter();
        ownerProto[setterName] = me.createSetter();
    },

<span id='Ext-data-***REMOVED***ociation-BelongsTo-method-createSetter'>    /**
</span>     * @private
     * Returns a setter function to be placed on the owner model's prototype
     * @return {Function} The setter function
     */
    createSetter: function() {
        var me = this,
            foreignKey = me.foreignKey;

        //'this' refers to the Model instance inside this function
        return function(value, options, scope) {
            // If we p***REMOVED*** in an instance, pull the id out
            if (value &amp;&amp; value.isModel) {
                value = value.getId();
            }
            this.set(foreignKey, value);

            if (Ext.isFunction(options)) {
                options = {
                    callback: options,
                    scope: scope || this
                };
            }

            if (Ext.isObject(options)) {
                return this.save(options);
            }
        };
    },

<span id='Ext-data-***REMOVED***ociation-BelongsTo-method-createGetter'>    /**
</span>     * @private
     * Returns a getter function to be placed on the owner model's prototype. We cache the loaded instance
     * the first time it is loaded so that subsequent calls to the getter always receive the same reference.
     * @return {Function} The getter function
     */
    createGetter: function() {
        var me              = this,
            ***REMOVED***ociatedName  = me.***REMOVED***ociatedName,
            ***REMOVED***ociatedModel = me.***REMOVED***ociatedModel,
            foreignKey      = me.foreignKey,
            primaryKey      = me.primaryKey,
            instanceName    = me.instanceName;

        //'this' refers to the Model instance inside this function
        return function(options, scope) {
            options = options || {};

            var model = this,
                foreignKeyId = model.get(foreignKey),
                success,
                instance,
                args;

            if (options.reload === true || model[instanceName] === undefined) {
                instance = Ext.ModelManager.create({}, ***REMOVED***ociatedName);
                instance.set(primaryKey, foreignKeyId);

                if (typeof options == 'function') {
                    options = {
                        callback: options,
                        scope: scope || model
                    };
                }
                
                // Overwrite the success handler so we can ***REMOVED***ign the current instance
                success = options.success;
                options.success = function(rec){
                    model[instanceName] = rec;
                    if (success) {
                        success.apply(this, arguments);
                    }
                };

                ***REMOVED***ociatedModel.load(foreignKeyId, options);
                // ***REMOVED***ign temporarily while we wait for data to return
                model[instanceName] = instance;
                return instance;
            } else {
                instance = model[instanceName];
                args = [instance];
                scope = scope || options.scope || model;

                //TODO: We're duplicating the callback invokation code that the instance.load() call above
                //makes here - ought to be able to normalize this - perhaps by caching at the Model.load layer
                //instead of the ***REMOVED***ociation layer.
                Ext.callback(options, scope, args);
                Ext.callback(options.success, scope, args);
                Ext.callback(options.failure, scope, args);
                Ext.callback(options.callback, scope, args);

                return instance;
            }
        };
    },

<span id='Ext-data-***REMOVED***ociation-BelongsTo-method-read'>    /**
</span>     * Read ***REMOVED***ociated data
     * @private
     * @param {Ext.data.Model} record The record we're writing to
     * @param {Ext.data.reader.Reader} reader The reader for the ***REMOVED***ociated model
     * @param {Object} ***REMOVED***ociationData The raw ***REMOVED***ociated data
     */
    read: function(record, reader, ***REMOVED***ociationData){
        record[this.instanceName] = reader.read([***REMOVED***ociationData]).records[0];
    }
});
</pre>
</body>
</html>
